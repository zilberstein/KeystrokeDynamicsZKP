\documentclass[11pt]{article}

% This first part of the file is called the PREAMBLE. It includes
% customizations and command definitions. The preamble is everything
% between \documentclass and \begin{document}.

\usepackage[margin=1in]{geometry}  % set the margins to 1in on all sides
\usepackage{graphicx}              % to include figures
\usepackage{amsmath}               % great math stuff
\usepackage{amsfonts}              % for blackboard bold, etc
\usepackage{amsthm}                % better theorem environments
\usepackage{array}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows}
\usetikzlibrary{positioning}

% various theorems, numbered by section

\newtheorem{thm}{Theorem}[section]
\newtheorem{lem}[thm]{Lemma}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{cor}[thm]{Corollary}
\newtheorem{conj}[thm]{Conjecture}

\DeclareMathOperator{\id}{id}

\newcommand{\bd}[1]{\mathbf{#1}}  % for bolding symbols
\newcommand{\RR}{\mathbb{R}}      % for Real numbers
\newcommand{\ZZ}{\mathbb{Z}}      % for Integers
\newcommand{\col}[1]{\left[\begin{matrix} #1 \end{matrix} \right]}
\newcommand{\comb}[2]{\binom{#1^2 + #2^2}{#1+#2}}


\begin{document}
% Define block styles
\tikzstyle{decision} = [diamond, draw, fill=blue!20, 
    text width=2em, text badly centered, inner sep=0pt]
\tikzstyle{block} = [rectangle, draw, fill=blue!20, 
    text width=5em, text centered, rounded corners, minimum height=2em]
\tikzstyle{line} = [draw, -latex']
\tikzstyle{cloud} = [draw, ellipse,fill=red!20,
    minimum height=2em]

\title{A Zero-Knowledge Protocol for Keystroke Authentication}

\author{Noam Zilberstein and Jonanthan Chen\thanks{Advised by Nadia Henninger} \\
University of Pennsylvania
}

\maketitle

\begin{abstract}
  We present a protocol to authenticate users without the use of a password. Passwords have many inherent problems. Several well known companies such as Dropbox and Apple have recently been targets of large scale security breaches in which passwords were compromised. Because of this risk, users are urged to use different passwords for each account. It is very difficult to create and remember enough secure passwords considering how many online accounts most people have today.

Many common websites such as Facebook and Dropbox are already encouraging the use two-factor authentication to subvert these issues. These forms of authentication usually involve confirming the possession of a piece of hardware. Instead, we suggest an alternate authentication factor that does not require possession of additional hardware. This authentication scheme is based on keystroke dynamics; the user is authenticated based on the timing of his/her keystrokes when typing a particular phrase (such as their name). When typing, each individual has their own typing pattern consisting of lag and dwell time (how long a key is pressed) and rhythms (typing certain clusters of letters faster).  This typing pattern translates into a typing signature which can be measured and used as a form of biometric data.
\end{abstract}

\section{Introduction}
Using passwords for authentication is an ancient concept that continues to be the commonly accepted standard. For the sake of convenience, many people choose low-strength passwords and reuse them for multiple websites~\cite{Florencio:2007:LSW:1242572.1242661}. This is extremely insecure and begs the question: is there a better way to authenticate \textit{lazy} users?

Several fixes to this problem are already in place and work by augmenting the password with a secondary authentication factor. Websites that suport two factor authentication include Amazon, Facebook, Google, Dropbox, and many others~\cite{2fac}. In each case, the first factor is a password and the second factor is some kind of trusted hardware (personal computer, smartphone, etc). When a user tries to log in from an untrusted machine, he must confirm his identity by typing a code that is sent to a trusted source such as an SMS, email, or phone call. While this process greatly improves the security of a poorly chosen password, it is still a hastle for the lazy user. It also fails if the user does not have access to a trusted piece of hardware. The solution presented in this paper uses trusted hardware that the user has at all times: his hands.

We propose an authentication protocol based on keystroke dynamics; the unique timings associated with the way that a user types. The protocol we present uses keystroke dynamics as the sole authentication factor, however this protocol could easily be extended to incorporate more factors. As stated before, keystroke dynamics act as a hardware factor without requiring users to carry any piece of physical hardware with them other than their hands. Login on an untrusted machine is therefore equally as secure as login from a trusted one, but it also requires no extra steps on behalf of the user.

A problem arrises with this protocol in the case that the database containing users' keystroke data is compromised. In a password model, if a user's password is leaked, then he can simply create a new one. However, in an authentication scheme based on keystroke dynamics, if an adversary gains knowledge of keystroke data, then the affected users can never confidently use keystroke dynamics to authenticate themselves again. In order to fix this, as little data as possible should be stored in the database. In fact, the protocol we present is zero-knowledge. This means that a user will never at any point in the enrollment or authentication process jeopardize the secrecy of his keystroke timings.

In Section~\ref{sec:related}, an overview of prior and similar work is provided. Next, a summary of the methodology and techniques that are used is explained in Section~\ref{sec:methods}. The protocol itself is defined in Section~\ref{sec:results}; first, a standard (but insecure) protocol is defined as a point of comparison and then the several improvements are made to arrive at the zero-knowledge version. The tradeoffs and challenges of zero-knowledge keystroke authentication are also examined in this section. Finally, future work is discussed in Section~\ref{sec:future}.

\section{Related Work}
\label{sec:related}
The final protocol that we present brings together many concepts from the fields of cryptography, complexity theory, and information theory. This section gives overviews of these ideas based on prior work.

\subsection{Keystroke Dynamics}
\label{sec:bg-keystroke}
Long before computers were invented, written signatures were used to verify people's identities. Signatures are commonly used to confirm the acceptance of contracts and to verify credit card and bank transactions. Typing one's name into a computer is the digital age's moral equivalent to writing it down on a piece of paper. It is not considered a breach of security to see someone's signature witten on a piece of paper; the security assumption is that another person cannot copy it to a sufficient level of precision. Similarly, a person types his name with high enough frequency that he develops a muscle memory for this process~\cite{monrose:authentication}.

Of course, the fact that a person can consistently type his name with the same keystroke timings does not alone make keystroke dynamics a good authentication technique; it is necessary, but not sufficient. If many people type in very similar ways, then they will all be authenticated as each other. There must be sufficient entropy in the keystroke timings. In other words, a vector of keystroke timings must contain enough information to differentiate between users. In 1999, Monrose, Reiter, and Wetzel showed that there is a relatively small amount of entropy in a keystroke vector generated by typing a fixed 8-character password~\cite{Monrose:1999:PHB:319709.319720}. However, this does not rule out the possibility of keystroke based authentication. In the same way that long passwords are considered more secure than short ones, longer keystroke vectors contain more entropy than short ones. Many more bits of entropy are generated by typing ``Arnold Schwarzenegger
'' than by typing ``John Doe''. Most people have names that are longer than eight characters, so the entropy will be boosted over the results of Monrose, Reiter, and Wetzel~\cite{Monrose:1999:PHB:319709.319720}. In addition, people can generally type their own name with more consistency than an arbitrary word (this conjecture was validated in our trials). This means that the protocol can have less slack than the one used to measure entropy in the experiments of Monrose, Reiter, and Wetzel~\cite{Monrose:1999:PHB:319709.319720}.

In fact, despite potential entropy concerns, Ara\'ujo, Sucupira, Lizarraga, Ling, and Yabu-Uti showed that people can be authenticated by measuring keystroke timings with roughly 99\% accuracy~\cite{Araujo:2005:UAT:2197882.2199456}. This means that the false acceptance rate (FAR) and false rejection rate (FRR) are both about 1\%. The tolerance of the model can be tuned in order to obtain slightly different rates. The FAR and The FRR are inversely related; by increasing the false rejection rate, the false acceptance rate will decrease thereby making the protocol more secure (but harder to be authenticated). This idea will be examined in detail in Section~\ref{sec:results}.

So far, the threat model being used has only assumed that the adversary is an actual human being. That is, no person can accurately reproduce another person's keystrokes by watching him type (or any other means). In reality, the adversary may not be a human, but rather an automated script. If some user's keystroke timings were compromised, this information would not help another human impersonate the user. However, an adversary could write a script that produces keystrokes with the precise timings that are expected. In 2010, Stefan and Yao showed that given a pool of keystroke data for users other than the target, an automated bot cannot impersonate the target~\cite{conf/colcom/StefanY10}. However, there is no defense against a bot that does know the timings of its target. This is why it is of utmost importance that the authentication protocol leaks no information about the user's keystroke timings. The following sections give additional background of the concepts that will be necessary in the construction of the zero-knowledge protocol.

\subsection{Zero-Knowledge Proofs for Authentication}
\label{fig:bg-zkp}
In the classical definition of a zero-knowledge proof, a prover $P$ must convince a less powerful verifier $V$ of some fact without giving away any information that would allow $V$ to prove it himself~\cite{GMW86}. An intuitive example of this is the following:

\begin{quote}\small
Peggy would like to convince Victor that two cards are different colors, however Victor is color blind. First, Victor holds up the two cards and asks Peggy to identify the color of each one. Victor then labels the back of the two cards with Peggy's responses, shuffles them behind his back and then asks Peggy to again identify the color of each one. If the cards indeed have different colors, then Peggy can easily identify them. However, if the cards are the same color then she can only give an answer that is consistent with the labels with probability $\frac12$. By repeating this process several times, Victor can be sure that Peggy is not lying, however he cannot recreate the proof himself because he is color blind.
\end{quote}

\noindent Relating this to an authentication protocol, the user can be viewed as a prover who knows some secret and the server is a verifier that must confirm that the user knows the secret, but has no access to the secret itself. In the case of keystroke dynamics, the secret is the user's keystroke timings. In a sense the user does not ``know'' his timings, but as stated in Section~\ref{sec:bg-keystroke}, he can consistently produce them. If the user knows the secret then he should always be able to prove his identity, but an imposter should not be able to prove knowledge of the secret with high probability. These conditions relate directly to the example above; if Peggy were cheating, then she would only have a small probability of guessing the labels correctly many times. In an authentication scheme, this failure probability should be negligably small. In other words, the probability that someone can prove that he is a certain user without knowing that user's secret is negligable.

A zero-knowledge protocol for proving knowledge of a secret already exists and is based on the discrete log problem. In the discrete problem, the inputs are integers $g$, $y$, and $p$ where $p$ is prime and the output is an integer $x$ such that $g^x\equiv y\mod p$. It is commonly believed that the discrete log problem is hard, meaning that it generally cannot be solved in polynomial time. This means that if $x$ is some secret, then a user can broadcast the value $g^x\mod p$ with confidence that no one will be able to determine $x$. A protocol for proving knowledge of $x$ without revealing $x$ is provided in Figure~\ref{fig:dlp-zkp}~\cite{crypto-1986-1125}. Note that all operations are done mod $p$. If the prover knows the secret, then the verifier is guaranteed to accept:

$$ah^b = (g^r)(g^x)^b = g^{r + xb} = g^c$$

However, if the prover does not know the secret, then he would have to produce an alternate value for $c$ such that $g^c\equiv g^{r+bx}\mod p$. The probability of being able to do this is negligable. The protocol is zero knowledge because, by the discrete log assumption, an adversary can gain no information about $r$ from the value $g^r$, and without $r$ is it impossible to determine $x$ from the value $r + xb$.

\begin{figure}
\centering
\fbox{
\begin{tabular}{m{2.5in}m{.5in}m{2.5in}}
\textbf{Prover} (knows $x$) && \textbf{Verifier} (knows $h=g^x\mod p$)\\
Randomly choose $r\in\ZZ_g$, let $a=g^r$ & $\stackrel{a}{\longrightarrow}$ & \\
& $\stackrel{b}{\longleftarrow}$ & Randomly choose $b\in\ZZ_g$\\
Let $c = r + xb$ & $\stackrel{c}{\longrightarrow}$ & $ah^b \stackrel{?}{=} g^c$
\end{tabular}}
\caption{Zero-Knowledge Proof for the Discrete Log Problem}
\label{fig:dlp-zkp}
\end{figure}

This protocol can certainly be used to authenticate users when the secret $x$ is some fixed value. However, in the case of keystroke dynamics, the secret may have variations. That is, the timings will be slightly different on each trial~\cite{monrose:authentication}. In a regular protocol this is not a problem; with access to the timing data itself, it is easy to calculate the distance between the actual timings and expected ones. With zero knowledge, this is more difficult. Instead of calculating a distance, the random noise in the sample must be removed in order to obtain a unique value.

\subsection{Fuzzy Extractors}
\label{sec:fuzzy}
Fuzzy extractors are used to extract a uniformly random string $S$ from a noisy input $\mathfrak{B}$, also known as a biometric template. A similar input $\tilde{\mathfrak{B}}$ will product the exact same string $S$~\cite{conf/csreaSAM/AlvarezEA09}. In the case of keystroke based authentication, $S$ is a user's unique signature which can be extracted from a noisy input. It is then possible to prove knowledge of the secret value $S$ using a zero-knowledge proof. The following construction for a fuzzy extractor is due to \'Alvarez, Encinas, Hern\'andez, and Sanchez-Avila.

The enrollment phase for the fuzzy extractor is shown in Figure~\ref{fig:enroll}~\cite{conf/csreaSAM/AlvarezEA09}. Given a biometric template $\mathfrak{B}$ and a secret $S$, the enrollment function produces additional data $H$ and $\Delta$ that are used to recover $S$. The values of $H$ and $\Delta$ can safely be made public without compromising the security of the secret $S$. First, the secret is represented as an integer in base $b$, ie $S = s_0s_1\ldots s_d$ where $d = \log_b S$. A polynomial $p(x)$ is now derived whose coefficients are the base $b$ digits of $S$:

$$p(x) = s_0 + s_1x + s_2x^2 + \cdots + s_dx^d$$

Next, $n$ random integers $x_1, x_2, \ldots, x_n$ are generated and $p(x)$ is evaluated at each of these points to obtain $y_i = p(x_i)$. The value $n$ controls how fuzzy an accepting template can be. For technical reasons, $n$ must be much greater than $d$. The $n$ coordinate pairs are then concatenated together as $x_i||y_i$ and encoded using a Reed-Solomon code to form the set $C = \{c_1, c_2,\ldots, c_n\}$. A Reed-Solomon code is an encoding of a message using extra bits such that if the message is corrupted, it can still be recovered accurately~\cite{reed60polynomial}. A hash function $\mathfrak{h}$ is applied to all of the Reed-Solomon encoded values to obtain $H = \{\mathfrak h(c_1), \mathfrak h(c_2), \ldots, \mathfrak h(c_n)\}$. The input template $\mathfrak B$ is divided into $n$ parts $b_1||b_2||\ldots||b_n$ and each entry in $\Delta = \{\delta_1, \delta_2, \ldots, \delta_n\}$ is obtained as $\delta_i = c_i - b_i$. The values $H$, $\Delta$, $b$, $d$, and $\mathfrak h$ are then stored to be used for extraction~\cite{conf/csreaSAM/AlvarezEA09}.

\begin{figure}[h!]
\centering
\begin{tikzpicture}[node distance = .5cm and 1cm]
    % Place nodes
    \node [block] (msg) {Message};
    \node [block, right= 3cm of msg] (enc) {Encoded Message};
    \node [decision, right= of enc] (plus) {$-$};
    \node [below= of enc] (hash) {$H$};
    \node [below= of plus] (delta) {$\Delta$};
    \node [above= of plus] (temp) {$\mathfrak{B}$};
    \node [block, above left= of msg] (poly) {$p(x)$};
    \node [left= of poly] (secret) {Secret ($S$)};
    \node [below left= of msg] (rand1) {};
    \node [left= of rand1] (rand) {Random Inputs};
    % Draw edges
    \path [line] (secret) -- (poly);
    \path [line] (rand) -| (poly);
    \path [line] (poly) -| node [midway, above] {$y_1y_2\ldots y_n$} (msg);
    \path [line] (rand) -| node [midway, below] {$x_1x_2\ldots x_n$} (msg);
    \path [line] (msg) -- node [midway, above] {\tiny Reed-Solomon Code} (enc);
    \path [line] (enc) -- (hash);
    \path [line] (enc) -- (plus);
    \path [line] (plus) -- (delta);
    \path [line] (temp) -- (plus);
\end{tikzpicture}
\caption{Enrollment phase for a Fuzzy Extractor}
\label{fig:enroll}
\end{figure}

The key feature of a fuzzy extractor is the ability to extract the secret $S$ given a noisy, but genuine, template $\tilde{\mathfrak B}$. The extraction process is detailed in Figure~\ref{fig:extract}. First, the query template $\tilde{\mathfrak B}$ is partitioned into $n$ parts $\tilde b_1||\tilde b_2||\ldots||\tilde b_n$ and each part is added with the corresponding element of $\Delta = \{\delta_1, \delta_2,\ldots,\delta_n\}$ to get $\tilde C = \{\tilde c_1, \tilde c_2, \ldots, \tilde c_n\}$. The values of $\tilde C$ should be similar to those of $C$, however they will be slightly different due to variations in the noisy template $\mathfrak B$. Note that the values of $C$ are not known, but that hashed values of $C$ are, so the entries of $\tilde C$ are also hashed to obatin $\tilde H = \mathfrak h(\tilde C)$ and the entries of $\tilde H$ are compared to those of $H = \mathfrak h(C)$. If at least $d+1$ of the entries in $H$ are equal to the corresponding entries in $\tilde H$ then $\tilde{\mathfrak B}$ is precise enough to be decoded, otherwise the system immediately rejects.

The next step is to obtain the $(x, y)$ pairs using the Reed-Solomon code. Since there were at least $d+1$ matching hashes, at least $d+1$ coordinate pairs will be decoded. The next step is to use Lagrange Interpolation to recover the polynomial $p(x)$. Interpolation of a polynomial of degree $d$ requires at least $d+1$ points, thus it is crucial that at least $d+1$ points are decoded. The parameter $n$ defines the amount of fuzziness that is allowed. Since there are a fixed number of points \textit{needed} to interpolate the polynomial, increasing $n$ decreases the fraction of the partitions of $\mathfrak B$ that must be accurate. Once $p(x)$ is known, it is easy to determine the secret $S$. Each base $b$ digit of $S$ is simply a coefficient of $p(x)$~\cite{conf/csreaSAM/AlvarezEA09}.

\begin{figure}[h!]
\centering
\begin{tikzpicture}[node distance = .5cm and .75cm]
    % Place nodes
    \node (temp) {$\tilde{\mathfrak B}$};
    \node [decision, right= of temp] (plus) {$+$};
    \node [above= of plus] (delt) {$\Delta$};
    \node [below = of plus] (reject) {Reject};
    \node [decision, right = of plus] (decide) {$\stackrel?=$};
    \node [above = of decide] (h) {$H$};
    \node [block, right= 2cm of decide] (dec) {Decode $(x_i,y_i)$};
    \node [block, right= 1.5cm of dec] (coeff) {$p(x)$};
    \node [right= of coeff] (s) {$S$};
    % Draw edges
    \path [line] (temp) -- (plus);
    \path [line] (delt) -- (plus);
    \path [line] (plus) -- node [midway, above] {$\mathfrak h$} (decide);
    \path [line] (h) -- (decide);
    \path [line] (decide) -- node [midway, below] {\tiny Reed-Solomon}
      node [near start, above] {\tiny yes} (dec);
    \path [line] (decide) |- node [near start, right] {\tiny no} (reject);
    \path [line] (dec) -- node [midway, above] {\tiny Interpolate} (coeff);
    \path [line] (coeff) -- (s);
\end{tikzpicture}
\caption{Extraction phase for a Fuzzy Extractor}
\label{fig:extract}
\end{figure}

\'Alvarez, Encinas, Hern\'andez, and Sanchez-Avila showed that the above method of fuzzy extraction has a genuine acceptance rate of 89\% and a false acceptance rate of around 1\% on iris scan authentication~\cite{conf/csreaSAM/AlvarezEA09}. While a different biometric such as keystroke dynamics would undoubtably produce different error rates, prior work shows that this fuzzy extractor has potential to accurately distinguish between people. The genuine acceptant rate of 89\% is fairly good; it implies that the expected number of trials that a person will need to perform in order to authenticate themself is $\frac{100}{89}\approx 1.12$. In the context of the keystroke dynamics protocol, this is convenient enough to satisfy a lazy user. In most instances, the user will only have to type his name once, but occasionally a second trial may be required.

Prior work shows that authentication via keystroke dynamics is feasible~\cite{monrose:authentication}. However, storing information about keystroke timings in a database is dangerous, therefore a zero-knowledge keystroke authentication protocol is very attractive. A protocol already exists to prove knowledge of a secret without giving away any information~\cite{crypto-1986-1125}. This protocol relies on the secret being an exact value, not a noisy sample such as a keystroke timing vector. This problem is solvable using a fuzzy extractor to retrieve an exact secret from a noisy input~\cite{conf/csreaSAM/AlvarezEA09}. Composing these ideas, a zero-knowledge keystroke dynamics authentication protocol can be created.

\section{Methodology and Techniques}
\label{sec:methods}

We wish to examine the feasibility of keystroke based authentication from both a theoretical and empirical perspective. Two protocols are presented. The first procotol is extremely insecure, but acts as a proof of concept and comparison baseline in terms of accuracy and security. This protocol has been implemented as a simple web app. The second protocol is a zero-knowledge version of the first one that relies on an extractor to obtain a secret from a noisy input. The secret is never stored or communicated across a network; instead knowledge of the secret is proven using a zero-knowledge protocol. This protocol has been implemented using a rounding extractor and the feasibility of using the fuzzy extractor that is described in Section~\ref{sec:fuzzy} is also examined.

When discussing these protocols, the words \textit{prover} and \textit{client} are used almost interchangeably as are the words \textit{verifier} and \textit{server}. The client is an implementation of a prover and the server is an implementation of a verifier. The client is naturally more `powerful' than the server as the client knows the secret keystroke timings (or can at least extract them from a noisy input). Both the regular and the zero-knowledge versions of the web app have two capabilites: account creation and login. The account creation phase requires a user to type their name in a text box. The keystroke timings are recorded and communicated to the server. The server then stores some data about the keystrokes in a database. When a user tries to log in, he also simply types his name in a text box. The name that he typed is looked up in the database and then his keystroke timings are compared against the ones that are stored. Note that the word \emph{compare} is used loosely here; in the zero-knowledge protocol, no direct comparison occurs per se. The user experience is identical in the regular and zero-knowledge versions, although the implementation is quite different.

\subsection{The Basic Protocol}

The basic protocol authenticates users by directly comparing the given keystroke vector to the expected keystroke vector. This protocol is not designed with security in mind; any adversary that can see the information exchange between the prover and the verifier will be able to directly discern the keystroke vectors. More concretely, anyone evesdropping on the communications over the netork can see these values communicated in the clear. This protocol is not meant to be used in a real implementation of the system, but instead it is meant to be a point of comparison for the zero knowledge version.

\begin{figure}[h!]
\centering
\fbox{
\begin{tabular}{m{2.5in}m{.5in}m{2.5in}}
\textbf{Prover} && \textbf{Verifier}\\
User types name ($A$) in web client. Keystroke vector ($V$) is recorded &$\xrightarrow{(A, V)}$ & $(A,V)$ is stored in the database
\end{tabular}}
\caption{Account creation in the basic protocol}
\label{fig:basic_new}
\end{figure}

Let $V=v_1v_2\ldots v_n$ be the real keystroke vector for user $A$ and $\tilde V = \tilde v_1\tilde v_2\ldots\tilde v_n$ be the keystroke vector associated with a login attempt by someone claiming to be $A$. Account creation in the basic protocol is very simple. First, the prover sends a pair $(A,V)$ containing the user's name and keystroke timings to the verifier. The verifier then stores this information in its knowledge bank. This protocol is outlined in Figure~\ref{fig:basic_new}. Authentication (as seen in Figure~\ref{fig:basic_auth}) is then performed by applying a comparison function $c$ to the expected keystroke vector for user $A$ and the login vector. The comparison function that is used in the actual implementation is defined as follows:
$$\begin{array}{ccc}
c(V,\tilde V) = \begin{cases}
  1, & d(V, \tilde V) \le \varepsilon \\
  0, & \text{otherwise}
\end{cases}
& \;\;\;\;\; &
d(V,\tilde V) = \sqrt{\frac1n\sum_{i=1}^n(v_i - \tilde v_i)^2}
\end{array}$$
Above, $\varepsilon$ is a constant error tolerance which is carefully chosen considering the tradeoffs between security and ease of login. This tradeoff will be examined closely in section~\ref{sec:results}.

\begin{figure}[h!]
\centering
\fbox{
\begin{tabular}{m{2.5in}m{.5in}m{2.5in}}
\textbf{Prover} && \textbf{Verifier}\\
User types name ($A$) in web client. Keystroke vector ($\tilde V$) is recorded &$\xrightarrow{(A, \tilde V)}$ & Lookup key $A$ in the database to get $V$\\
Report result&$\xleftarrow{f(V, \tilde V)}$ & Send decision
\end{tabular}}
\caption{Authentication in the basic protocol}
\label{fig:basic_auth}
\end{figure}


Disregarding the fact that the keystroke vector $V$ is immediately discernable from eavesdropping on the account creation process, this protocol will be the baseline for evaluating the performance of the zero-knowledge version.

\subsection{The Zero-Knowledge Protocol}
The zero knowledge builds on top of the basic protocol with the added constraint that no meaningful information about the keystroke vector is ever transferred accross the network. This also means that the representation of the keystroke vector that is stored in the database does not leak any information about the keystroke vector itself. If the database were completely compromised, there would thus be no breach in security; the information in the database can be used to verify a user's identity and nothing more.


\begin{figure}
\centering
\fbox{
\begin{tabular}{m{2.5in}m{.5in}m{2.5in}}
\textbf{Prover} && \textbf{Verifier}\\
Choose some generator $g$ & $\xrightarrow{g}$ & Remember $g$\\
User types name ($A$) in web client. Keystroke vector ($V$) is recorded. Let $h = g^{f(V)}$ &$\xrightarrow{h}$ & $(A,g,h)$ is stored in the database
\end{tabular}}
\caption{Account creation in the zero-knowledge protocol}
\label{fig:zk_new}
\end{figure}

\begin{figure}
\centering
\fbox{
\begin{tabular}{m{2.5in}m{.5in}m{2.5in}}
\textbf{Prover} && \textbf{Verifier}\\
User types name ($A$) in web client. Keystroke vector ($\tilde V$) is recorded &$\stackrel{A}{\longrightarrow}$ & \\
&$\stackrel{g}\longleftarrow$ & Lookup key $A$ in the database to get $g$ and $h$\\
Choose $r\in_R\mathbb{Z}_g$, let $a = g^r$ & $\stackrel{a}\longrightarrow$ & \\
& $\stackrel{b}\longleftarrow$ & Choose $b\in_R\mathbb{Z}_g$ \\
Let $c = r + f(\tilde V)\cdot b$ & $\stackrel{c}\longrightarrow$ & \\
Report decision & $\stackrel{ah^b \stackrel{?}{=} g^c}\longleftarrow$ &
\end{tabular}}
\caption{Authentication in the zero-knowledge protocol}
\label{fig:zk_auth}
\end{figure}


\section{Results}
\label{sec:results}
Performance of these systems will be analysed using two metrics: how easy it is for a person to repeatedly log in and how easy it is for an adversary to impersonate a user. As stated in Section~\ref{sec:bg-keystroke}, this adversary may not be an actual person; it may be a bot that is programmed to reproduce an exact sequence of keystrokes. This means that is the actual timing vector is compromised, then the protocol is totally insecure.


\section{Future Work}
\label{sec:future}

\bibliographystyle{plain}

\bibliography{paper}


\end{document}
